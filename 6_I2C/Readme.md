#### Signal Line
The I2C is a serial bus protocol consisting of two lines such as SCL and SDL lines which are used to communicate with the devices
    - SCL stand for (serial clock line), and this signal is always driven by the master line.
    - SDL stand for (serial data line), and the SDL signal is generated by either the master or the I2C peripherals.
Both these SCL and SDL lines are in an open-drain state when there is no transfer between I2C peripherals.

#### How I2C works?
- Message Structure:
Each message has an address frame that contains the binary address of the slave and one or more data frames that contain the data being transmitted.
The message also include start and stop conditions, read/write bits, and ACK/NACK bits between each data frame.

![1](/6_I2C/1.png)

- Address phase:
In the address phase, the first 7 bits are the address of the slave. So, the slave address is 7 bits. The remaining one bit decide to read or write operation and this is called R/W.
- Write operation:
If R/W bits is 0, that indicates is going to write data or master is going trasmit the data.
In the address phase, the master is going to send 8 bits and the slave is going to receive these 8 bits. If there is any match, then the slave is going to ship acknowledgment (ACK) to the master.
Then the master receive the ACK, it is going to write operation. When the slave receive this data, slave going to send ACK saying that it collected data byte.
- Read operation:
If R/W bit is 1, the master is going to read data from the slave.
In the address phase, the master is going to send 8 bits and the slave is going to receive these 8 bits. If there is any match, the slave is going to send the ACK to the master.
Then the master receive data from the slave. If the master got sufficient data, the master generates a stop condition.
- Start bit and Stop bit:
The start and stop conditions that are generated by the master.

![2](/6_I2C/2.png)

For both conditions, SCL has to be high. A high to low transition of SDA is considered as START and a low to high transition as STOP. After the start condition, the bus is considered as busy and can be used by another master only after a Stop condition is detected.
#### ACK/NACK bit
![4](/6_I2C/4.png)

- Chu kỳ xung nhịp thứ 9 của SCL dành cho ACK và NACK.
- Nếu đường SDA kéo lên cao thì đó là NACK. Vì vậy, khi đường SDA ở mức cao trong xung nhịp thứ 9 của SCL, đây được gọi là tín hiệu không xác nhận. - Sau NACK, thiết bị chủ có thể tạo điều kiện STOP để hủy bỏ quá trình truyền hoặc điều kiện BẮT ĐẦU lặp lại để bắt đầu quá trình truyền mới.
- Trong xung đồng hồ thứ 9 của SCL, nếu đường SDA ở mức thấp thì nó được chấp nhận là ACK và nếu đường SDA ở mức cao thì nó được chấp nhận là NACK. - Vì vậy, việc xác nhận diễn ra sau mỗi byte. Bit xác nhận cho phép bộ thu báo hiệu cho bộ phát rằng byte đã được nhận thành công và sẵn sàng nhận một byte khác. 
- Master tạo ra tất cả các xung đồng hồ, bao gồm cả việc xác nhận xung đồng hồ thứ 9. Vì vậy, máy phát luôn mong đợi ACK hoặc NACK trong chu kỳ xung nhịp thứ 9.
#### I2C Block Diagram
![3](/6_I2C/3.png)

- Trong sơ đồ khối chủ yếu có ba chân: SDA SCL SMBA. 
- SMBA là tín hiệu tùy chọn ở chế độ SMBus và tín hiệu này không áp dụng được nếu SMBus bị tắt. SMBus cung cấp bus điều khiển cho các tác vụ liên quan đến quản lý nguồn và hệ thống.
- Cả hai chân SDA và SCL đều được đặt trước một bộ lọc nhiễu được sử dụng để loại bỏ một số trục trặc hoặc xung đột,...
- Bộ lọc nhiễu được sử dụng để làm mịn tín hiệu SDA và SCL. 
- I2C là giao tiếp half-duplex vì chỉ có một thanh ghi dữ liệu trong sơ đồ khối của I2C. 
- Thanh ghi dữ liệu được kết nối với Data shift register. Vì vậy, dữ liệu sẽ ghi vào thanh ghi dữ liệu và sau đó nội dung của thanh ghi dữ liệu sẽ được sao chép vào data shift register.
- Từ data shift register, dữ liệu sẽ được truyền ra bên ngoài. 
- Khi dữ liệu đến từ bên ngoài, dữ liệu sẽ được chuyển đến data shift register và khi nhận được một byte hoàn chỉnh, dữ liệu sẽ được sao chép vào thanh ghi dữ liệu. Dữ liệu được đọc từ thanh ghi dữ liệu. 
- Thiết bị ngoại vi I2C có thể được sử dụng ở chế độ master hoặc chế độ slave. 
- Khi thiết bị ngoại vi I2C được cấu hình ở chế độ slave, thì địa chỉ slave được lưu trong own address register, chỉ có thể áp dụng khi thiết bị ở chế độ slave và thanh ghi này được sử dụng để lưu địa chỉ slave.
- Chân SCL được kết nối với khối điều khiển đồng hồ và khối điều khiển đồng hồ được kết nối với thanh ghi điều khiển đồng hồ (CCR). Bằng cách định cấu hình điều khiển đồng hồ, thanh ghi có thể tạo ra các tần số khác nhau trên chân đồng hồ nối tiếp (SCL).
#### I2C Init
- Bật Clock ngoại vi I2C.
```
I2C_PeriClockControl(pI2CHandle->pI2Cx, ENABLE);
```

- Cấu hình chế độ I2C là tiêu chuẩn hay nhanh.
- Cấu hình tốc độ của Clock (SCL). Tần số cao hơn không thể điều khiển bus I2C đi khoảng cách xa hơn nên chiều dài dây phải nhỏ khi sử dụng tần số cao hơn.
    ![10](/6_I2C/10.png)
    - I2C được nối với bus APB1 nên là ta sẽ lấy giá trị PCLK1 để tính toán cấu hình tần số xung nhịp ngoại vi ghi vào trường FREQ của thanh ghi CR2.
    ![11](/6_I2C/11.png)

- Cấu hình thanh ghi CCR:
    - Cấu hình mode và DUTY nếu ở FM
    ![12](/6_I2C/12.png)
    - Cấu hình bit CCR ở Sm/Fm
    ![13](/6_I2C/13.png)

    - Sm: Th + Tl = 1/f (Speech) = 2*CCR*(1/fPCLK1)
    - Fm: Nếu DUTY = 0 => CCR, Nếu DUTY = 1 => CCR
```
temp = 0;
uint16_t crr_value = 0;

if(pI2CHandle->I2C_Config.I2C_SCLSpeed == I2C_SCL_SPEED_SM)
{
    crr_value = (RCC_GetPCLK1Value() / (2 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
}
else
{
    temp |= (1 << 15);
    temp |= (pI2CHandle->I2C_Config.I2C_FMDutyCycle << 14);

    if(pI2CHandle->I2C_Config.I2C_FMDutyCycle == I2C_FM_DUTY_2)
    {
        crr_value = (RCC_GetPCLK1Value() / (3 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
    }
    else
    {
        crr_value = (RCC_GetPCLK1Value() / (25 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
    }
    temp |= (crr_value & 0xFFF);
}

pI2CHandle->pI2Cx->CCR = temp;
```
- Cấu hình địa chỉ thiết bị.

    ![9](/6_I2C/9.png)
    - bit thứ 14 trong thanh ghi OAR1 luôn giữ ở mức 1.
```
temp = 0;
temp |= pI2CHandle->I2C_Config.I2C_DeviceAddress << 1;
temp |= (1 << 14);
pI2CHandle->pI2Cx->OAR1 = temp;
```
- Kích hoạt ACK.
```
temp |= pI2CHandle->I2C_Config.I2C_AckControl << 10;
pI2CHandle->pI2Cx->CR1 = temp;
```

- Cấu hình thời gian tăng cho các chân I2C hoặc SDA và SCL. Thời gian tăng là thời gian cần thiết để tín hiệu đạt mức VCC từ mặt đất. Thời gian tăng còn được gọi là tốc độ quay, phải được cấu hình theo thông số kỹ thuật I2C. Hãy nhớ rằng tất cả các cấu hình trên phải được thực hiện khi thiết bị ngoại vi bị tắt. Thông thường, thiết bị ngoại vi bị tắt theo mặc định; nếu không, trước tiên hãy tắt nó trong thanh ghi điều khiển và sau đó thực hiện tất cả các thao tác khởi tạo ở trên. Sau khi quá trình khởi tạo hoàn tất, hãy kích hoạt thiết bị ngoại vi trong thanh ghi điều khiển.
    ![14](/6_I2C/14.png)

```
//TRISE
if(pI2CHandle->I2C_Config.I2C_SCLSpeed == I2C_SCL_SPEED_SM)
{
    temp = (RCC_GetPCLK1Value() / 1000000U) + 1;//số chu kỳ của PCLK1 tương ứng với 1 µs.
}
else
{
    temp = ((RCC_GetPCLK1Value() * 300)/ 1000000U) + 1;//số chu kỳ clock của PCLK1 tương ứng với thời gian tăng tối đa là 300 ns
}

pI2CHandle->pI2Cx->TRISE = (temp & 0x3F);
```

#### START condition
```
static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= (1 << I2C_CR1_START);
}
```
- Set bit START trong thanh ghi CR1

#### STOP condition
```
void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= (1 << I2C_CR1_STOP);
}
```
- Set bit STOP trong thanh ghi CR1

#### Xử lí địa chỉ
- Khi ở chế độ Write:
    ```
    static void I2C_ExecuteAddressPhaseWrite(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr)
    {
        SlaveAddr = SlaveAddr << 1;
        SlaveAddr &= ~(1);
        pI2Cx->DR = SlaveAddr;
    }
    ```
    - Dịch qua trái 1 bit vì ADD[7:1] trong thanh ghi OAR1
    - bit cuối của địa chỉ set thành 0 vì ở chế độ Write.

- Khi ở chế độ Read:
    ```
    static void I2C_ExecuteAddressPhaseRead(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr)
    {
        SlaveAddr = SlaveAddr << 1;
        SlaveAddr |= 1;
        pI2Cx->DR = SlaveAddr;
    }
    ```
    - Dịch qua trái 1 bit vì ADD[7:1] trong thanh ghi OAR1
    - bit cuối của địa chỉ set thành 1 vì ở chế độ Read.
#### Xóa cờ địa chỉ
- Nếu ở chế độ Master:
    - Kiểm tra trạng thái đang truyền hay đang nhận
        - Nếu đang truyền: Nếu Master chỉ nhận một byte dữ liệu thì Master sẽ không gửi ACK nhằm kết thúc truyền dữ liệu.
        - Tắt ACK
        - Đọc SR1 và SR2 để xóa cờ ADDR.
        - Nếu không phải truyền 1 byte thì chỉ cần đọc SR1 và SR2 để xóa.
- Nếu ở chế độ Slave thì chỉ cần đọc SR1 và SR2 để xóa

```
static void I2C_ClearADDRFlag(I2C_Handle_t *pI2CHandle)
{
	uint32_t dummy_read;
	//check device mode
	if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
	{
		//master mode
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
		{
			if(pI2CHandle->RxSize == 1)
			{
				I2C_ManageAcking(pI2CHandle->pI2Cx, DISABLE);

				dummy_read = pI2CHandle->pI2Cx->SR1;
				dummy_read = pI2CHandle->pI2Cx->SR2;
				(void)dummy_read;
			}
		}
		else
		{
			dummy_read = pI2CHandle->pI2Cx->SR1;
			dummy_read = pI2CHandle->pI2Cx->SR2;
			(void)dummy_read;
		}
	}
	else
	{
		//slave mode
		dummy_read = pI2CHandle->pI2Cx->SR1;
		dummy_read = pI2CHandle->pI2Cx->SR2;
		(void)dummy_read;
	}
}
```

#### I2C transfer sequence diagram for master sending data
![5](/6_I2C/5.png)

- Thiết bị truyền dữ liệu sẽ trở thành master, trước tiên phải kích hoạt điều kiện START.
```
//Start condition
I2C_GenerateStartCondition(pI2CHandle->pI2Cx);
```
- Khi điều kiện START được tạo thành công thì bit SB trong thanh ghi trạng thái sẽ được set lên 1.
```
//check SB Flag SR1
while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB));
```
- Trước khi chuyển qua giai đoạn địa chỉ thì master phải đợi cho đến khi SB lên 1.
- Cờ SB được xóa bằng cách đọc thanh ghi SR1, sau đó ghi vào thanh ghi DR một địa chỉ.
```
//send addr and w/r bit
I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx, SlaveAddr);
```
- Nếu bit SB không bị xóa thì SCL sẽ bị kéo dài có nghĩa là SCL sẽ được giữ ở mức thấp và master sẽ ở trạng thái chờ.
- Trong giai đoạn địa chỉ, 1 byte sẽ được truyền đi, trong đó 7 bit là địa chỉ của slave và 1 bit còn lại là bit R/W.
- Ở đây bit R/W = 0 vì master muốn gửi dữ liệu.
- Sau khi thực hiện giai đoạn địa chỉ, master sẽ chỉ nhận được ACK nếu Slave được chỉ định có mặt trên bus. Nếu Slave không có mặt trên bus thì master sẽ nhận được NACK.
```
//Check Addr Flag SR1
while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR));
```
- Master thực hiên xong giai đoạn địa chỉ thì bit ADDR của thanh ghi trạng thái set lên 1, nếu master nhận được NACK thì có nghĩa là giai đoạn địa chỉ thực hiện không thành công bit ADDR sẽ bằng 0. Xóa ADDR bằng cách đọc thanh ghi SR1.
```
I2C_ClearADDRFlag(pI2CHandle);
```
- Tiếp theo, set cờ TXE trong thanh ghi trạng thái bằng 1, có nghĩa là shift register và thanh ghi data đều trống, dấu hiệu để ghi dữ liệu vào thanh ghi DR. Việc ghi dữ liệu vào thanh ghi DR sẽ xóa cờ TXE.
- Khi dữ liệu vào thanh ghi DR ngay lập tức sẽ được sao chép qua shift register để đưa ra ngoài.
- Thanh ghi dữ liệu sẽ trống thì TXE sẽ được set lên 1 ngay lập tức, TXE được xóa khi dữ liệu đi vào thanh ghi DR.
- Sau khi truyền xong dữ liệu từ shift register ra bên ngoài thì Slave sẽ gửi bit ACK, sau khi nhận được ACK thì dữ liệu trong thanh ghi data sẽ chuyển qua shift register và thanh ghi dữ liệu trống thì TXE sẽ được set, và cứ lặp lại.
```
while(Len > 0)
	{
		while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_TXE));
		pI2CHandle->pI2Cx->DR = *pTxBuffer;
		pTxBuffer++;
		Len--;
	}
```

- Trước khi tạo điều kiện dừng, đợi cho TXE = 1 và BTF = 1, BTF biểu thị cho việc hoàn thành việc chuyển byte, khi tạo điều kiện dừng thì TXE và BTF sẽ tự động xóa bằng phần cứng
- Nếu NOSTRETCH = 0 thì việc kéo dài clock được bật. Việc kéo dài clock luôn được bật theo mặc định (bit NOSTRETCH trong thanh ghi SR1).
- Sau khi gửi byte cuối cùng và nhận ACK, thanh ghi dữ liệu sẽ trống vì không còn byte nào ghi vào thanh ghi dữ liệu. Sau khi truyền tất cả các bit thì shift register cũng sẽ trống. BTF sẽ được thiết lập cho biết thanh ghi dữ liệu và shift register đều trống. Clock sẽ được kéo dài sau khi truyền bit thứ N để tránh xảy ra hiện tượng chạy chậm và khiến master chuyển sang trạng thái chờ. Bây giờ điều kiện STOP có thể được nâng lên 1 các an toàn ở cuối vì quá trình truyền tất cả các byte đã hoàn tất.

```
while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_TXE));
while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_BTF));

if(Sr == I2C_DISABLE_SR)
{
    I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
}
```
#### I2C transfer sequence diagram for master receiving data
![6](/6_I2C/6.png)

- Trước tiên phải kích hoạt điều kiện START.
```
//Start condition
I2C_GenerateStartCondition(pI2CHandle->pI2Cx);
```

- Khi điều kiện START được tạo thành công thì bit SB trong thanh ghi trạng thái sẽ được set lên 1.

```
//check SB Flag SR1
while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB));
```

- Trước khi chuyển qua giai đoạn địa chỉ thì master phải đợi cho đến khi SB lên 1.
- Cờ SB được xóa bằng cách đọc thanh ghi SR1, sau đó ghi vào thanh ghi DR một địa chỉ.
- Nếu bit SB không bị xóa thì SCL sẽ bị kéo dài có nghĩa là SCL sẽ được giữ ở mức thấp và master sẽ ở trạng thái chờ.
- Trong giai đoạn địa chỉ, 1 byte sẽ được truyền đi, trong đó 7 bit là địa chỉ của slave và 1 bit còn lại là bit R/W.
- Ở đây bit R/W = 0 vì master muốn gửi dữ liệu.
```
//send addr and w/r bit
I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx, SlaveAddr);
```

- Sau khi thực hiện giai đoạn địa chỉ, master sẽ chỉ nhận được ACK nếu Slave được chỉ định có mặt trên bus. Nếu Slave không có mặt trên bus thì master sẽ nhận được NACK.
```
//Check Addr Flag SR1
while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR));
```

- Master thực hiên xong giai đoạn địa chỉ thì bit ADDR của thanh ghi trạng thái set lên 1, nếu master nhận được NACK thì có nghĩa là giai đoạn địa chỉ thực hiện không thành công bit ADDR sẽ bằng 0. Xóa ADDR bằng cách đọc thanh ghi SR1.
- Quá trình nhận dữ liệu sẽ diễn ra, shift register của master sẽ chứa đầy các bit dữ liệu đến từ Slave, sau khi nhận 1 byte hoàn chỉnh trong shift register, master sẽ gửi ACK cho Slave
- Sau khi nhận được ACK, cờ RXNE sẽ được đặt, cho biết bộ đệm nhận không trống. Khi RXNE được thiết lập, đó là xác nhận phần mềm có thể đọc dữ liệu từ bộ đệm nhận.
- Mặc dù RXNE được thiết lập nhưng shift register vẫn nhận byte tiếp theo đến từ Slave. Sau khi nhận byte thứ 2 Master sẽ gửi ACK đến Slave và phần mềm sẽ đọc dữ liệu từ bộ đệm nhận.
- Chỉ nên đọc từ thanh ghi dữ liệu của I2C nếu cờ RXNE được set, nếu không bạn sẽ không đọc được dữ liệu.
```
if(Len > 1)
	{
		I2C_ClearADDRFlag(pI2CHandle);

		for(uint32_t i = Len; i > 0; i--)
		{
			while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_RXNE));
            //Nhận 2 byte cuối cùng
			if(i == 2)
			{
                //Tắt tín hiệu ACK
				I2C_ManageAcking(pI2CHandle->pI2Cx, DISABLE);
                //Gửi tín hiệu STOP nếu cần
				if(Sr == I2C_DISABLE_SR)
				{
					I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
				}
			}

			*pRxBuffer = pI2CHandle->pI2Cx->DR;
			pRxBuffer++;
		}
	}
```

- Sau khi nhận được byte cuối cùng, Master sẽ gửi NACK đến Slave. Khi một Slave nhận được NACK nó sẽ hiểu là Master không muốn nhận thêm dữ liệu, NACK là dấu hiệu để ngừng gửi dữ liệu. Master tạo điều kiện dừng và nó cũng đọc byte cuối cùng được nhận.

```
if(Len == 1)
	{
		I2C_ManageAcking(pI2CHandle->pI2Cx, DISABLE);
		I2C_ClearADDRFlag(pI2CHandle);
		while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_RXNE));

		if(Sr == I2C_DISABLE_SR)
		{
			I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
		}

		*pRxBuffer = pI2CHandle->pI2Cx->DR;
	}
```
- Bật lại ACK nếu như tiếp tục gửi dữ liệu

```
if(pI2CHandle->I2C_Config.I2C_AckControl == I2C_ACK_ENABLE)
{
    I2C_ManageAcking(pI2CHandle->pI2Cx, ENABLE);
}
```

#### I2C transfer sequence diagram for slave transmitter
![7](/6_I2C/7.png)

- Cấu hình của master phải là read.
- Master tạo điều kiện bắt đầu.
- Master tạo giai đoạn địa chỉ.
- Trong giai đoạn địa chỉ, Slave gửi ACK, cờ ADDR được set lên bằng 1 biểu thị địa chỉ trùng khớp.
- Cờ ADDR đặt đồng hồ ở mức thấp và Master đợi Slave xóa cờ ADDR.
- Sau khi cờ ADDR được xóa, Cờ TXE được thiết lập biểu thị thanh ghi data và shift register trống, cho phép tải dữ liệu vào thanh ghi để truyền.
- Master gửi ACK sau khi nhận được dữ liệu từ Slave và cho biết rằng Master muốn có thêm dữ liệu.
- Khi Master gửi NACK cho byte dữ liệu cuối cùng biểu thị AF = 1.
- Master tạo điều kiện dừng, Khi nào Slave đang truyền mà lỗi ACK đồng nghĩa với việc quá trình truyền dữ liệu kết thúc.
#### I2C transfer sequence diagram for slave receive.
![8](/6_I2C/8.png)

- Cấu hình của master phải là write.
- Master tạo điều kiện bắt đầu.
- Master tạo giai đoạn địa chỉ.
- Trong giai đoạn địa chỉ, Slave gửi ACK, cờ ADDR được set lên bằng 1 biểu thị địa chỉ trùng khớp.
- Cờ ADDR đặt đồng hồ ở mức thấp và Master đợi Slave xóa cờ ADDR.
- Dữ liệu sẽ được nhận từ Master kèm với ACK.
- Khi Slave gửi ACK, RXNE sẽ được đặt thành 1.
- Trình điều khiển sẽ gửi đến ứng dụng để thông báo rằng byte dữ liệu đã sẵn sàng và đọc dữ liệu.
- Master nhận được byte cuối cùng, Slave sẽ gửi ACK, điều kiện dừng được Master tạo ra để báo hiệu nó không muốn nhận thêm dữ liệu.
- Cờ dừng được đặt thành 1, STOPF = 1 báo hiệu cho Slave biết rằng Master đã kết thúc ghi. 
- Nếu Slave phát hiện cờ dừng trong khi nhận dữ liệu thì đó là sự kết thúc quá trình nhận dữ liệu của Slave.
- Cờ STOPF chỉ đặt ở chế độ slave receive chứ không đặt ở chế độ slave transmitter. STOPF không áp dụng được cho master.
- Khi một Slave đang truyền dữ liệu, cờ dừng sẽ không xuất hiện. Do đó, ở slave transmitter, AF=1 là dấu hiệu cho thấy slave transmitter đã kết thúc truyền dữ liệu.
#### I2C Interrupt
##### SB (Start Bit Generated - Cờ SB):
- Bit SB trong thanh ghi SR1 và ITBUFEN trong thanh ghi CR2.
- Được set khi master gửi thành công tín hiệu START
- Cách xử lí: Gửi địa chỉ của Slave thông qua giai đoạn địa chỉ.

```
if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
{
    I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx, pI2CHandle->DevAddr);
}else if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
{
    I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx, pI2CHandle->DevAddr);
}
```
##### ADDR (Address Sent/Matched - Cờ ADDR)
- Bit ADDR trong thanh ghi SR1 và ITBUFEN trong CR2
- Được set khi:
    - Master nhận được phản hồi từ slave sau khi gửi địa chỉ.
    - Slave phát hiện địa chỉ của nó trên bus.
- Đọc thanh ghi SR1 và SR2 để xóa ADDR

```
I2C_ClearADDRFlag(pI2CHandle);
```
##### BTF (Byte Transfer Finished - Cờ BTF)
- Bit BTF trong thanh ghi SR1 và ITBUFEN trong CR2
- Được set khi:
    - Đã hoàn tất truyền dữ liệu byte cuối cùng.
    - Bộ đệm dữ liệu (Data Register - DR) rỗng và không còn byte nào đang được gửi.
- Cách xử lí:
    - Trong chế độ master, có thể gửi tín hiệu STOP hoặc tiếp tục truyền byte tiếp theo.
    - Trong chế độ slave, xác nhận hoàn tất quá trình truyền.

```
if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
{
    if(pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_TxE))
    {
        if(pI2CHandle->TxLen == 0)
        {
            if(pI2CHandle->Sr == I2C_DISABLE_SR)
            {
                I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
            }

            I2C_CloseSendData(pI2CHandle);

            I2C_ApplicationEventCallBack(pI2CHandle, I2C_EV_TX_CMPLT);
        }
    }
}
else if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
{
    if(pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_RxNE))
    {
        if(pI2CHandle->RxLen == 0)
        {
            if(pI2CHandle->Sr == I2C_DISABLE_SR)
            {
                I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
            }

            I2C_CloseReceiveData(pI2CHandle);

            I2C_ApplicationEventCallBack(pI2CHandle, I2C_EV_RX_CMPLTX);
        }
    }
}
```
##### STOPF (Stop Detection Flag - Cờ STOPF)
- Bit STOPF trong thanh ghi SR1 và ITBUFEN trong thanh ghi CR2.
- Được set khi master gửi tín hiệu STOP trong chế độ slave.
- Cách xử lí: Xóa cờ bằng cách đọc SR1 và ghi vào thanh ghi CR1.

```
pI2CHandle->pI2Cx->CR1 |= 0x0000;
I2C_ApplicationEventCallBack(pI2CHandle, I2C_EV_STOP);
```
#### TXE (Transmit Data Register Empty - Cờ TXE)
- Bit TXE trong SR1, ITBUFEN và ITEVTEN trong CR2
- Được set khi thanh ghi dữ liệu DR trống và sẵn sàng để nhận dữ liệu mới từ bộ xử lý.
- Cách xử lí: Ghi byte tiếp theo vào thanh ghi DR để gửi đến slave.

```
if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
{
    if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
    {
        I2C_MasterHandleTXEInterrupt(pI2CHandle);
    }
}else
{
    if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_TRA))
    {
        I2C_ApplicationEventCallBack(pI2CHandle, I2C_EV_DATA_REQ);
    }
}
```

##### RXNE (Receive Data Register Not Empty - Cờ RXNE)
- Bit RXNE trong SR1, ITBUFEN và ITEVTEN trong CR2
- Được set khi dữ liệu nhận được từ bus và sẵn sàng để đọc từ thanh ghi DR.
- Đọc dữ liệu từ thanh ghi DR vào bộ đệm nhận.
```
if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
{
    if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
    {
        I2C_MasterHandleRXNEInterrupt(pI2CHandle);
    }
}else
{
    if(! (pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_TRA)))
    {
        I2C_ApplicationEventCallBack(pI2CHandle, I2C_EV_DATA_RCV);
    }
}
```
##### AF (Acknowledge Failure - Cờ AF)
- Bit AF của thanh ghi SR1 và bit ITERREN của CR2.
- Được set khi master hoặc slave không nhận được tín hiệu ACK từ phía bên kia.
- Cách xử lí ghi bit AF bằng 0 và thông báo ra ngoài.
```
pI2CHandle->pI2Cx->SR1 &=~ (1 << I2C_SR1_AF);
I2C_ApplicationEventCallBack(pI2CHandle, I2C_ERROR_AF);
```
##### OVR (Overrun/Underrun - Cờ OVR)
- Bit OVR của thanh ghi SR1 và bit ITERREN của CR2.
- Được set khi:
    - Một byte dữ liệu mới được ghi vào thanh ghi DR trước khi byte hiện tại được truyền đi.
    - Byte mới được nhận vào DR trong khi DR chưa được đọc.
- Cách xử lí: Đọc thanh ghi SR1 và DR để xóa lỗi.
```
uint32_t temp = I2C1->SR1;
(void)temp = I2C1->DR;
pI2CHandle->pI2Cx->SR1 &=~ (1 << I2C_SR1_OVR);
I2C_ApplicationEventCallBack(pI2CHandle, I2C_ERROR_OVR);
```
##### TIMEOUT (Timeout Flag - Cờ TIMEOUT)
- Bit TIMEOUT của thanh ghi SR1 và bit ITERREN của CR2.
- Được set khi thời gian chờ vượt quá giá trị cấu hình trong giao thức SMBus.
- Cách xử lí: xóa bit TIMEOUT
```
pI2CHandle->pI2Cx->SR1 &=~ (1 << I2C_SR1_TIMEOUT);
I2C_ApplicationEventCallBack(pI2CHandle, I2C_ERROR_TIMEOUT);
```
##### ARLO (cờ ARLO)
- Bit ARLO của thanh ghi CR1 và bit ITERREN của CR2.
- Được set khi nhiều Master truyền dữ liệu cùng lúc.
- Cách xử lí xóa bit ARLO trong thanh ghi SR1.
```
pI2CHandle->pI2Cx->SR1 &=~ (1 << I2C_SR1_ARLO);
I2C_ApplicationEventCallBack(pI2CHandle, I2C_ERROR_ARLO);
```
##### BERR (cờ BERR)
- Bit BERR của thanh ghi CR1 và bit ITERREN của CR2.
- Được set khi xảy ra lỗi nghiêm trọng trên bus.
- Cách xử lí xóa bit BERR trong thanh ghi SR1.
```
pI2CHandle->pI2Cx->SR1 &=~ (1 << I2C_SR1_BERR);
I2C_ApplicationEventCallBack(pI2CHandle, I2C_ERROR_BERR);
```